{% extends "base.html" %}
{% from "_nav.html" import render_nav %}

{% block title %}Management - Blunder Tutor{% endblock %}

{% block content %}
<h1>Management</h1>
{{ render_nav('management') }}

<div class="card">
  <h2>Bulk Import Games</h2>
  <div id="importMessage" style="display: none;"></div>
  <form id="importForm">
    <div class="form-group">
      <label for="source">Source</label>
      <select id="source" required>
        <option value="">Select source...</option>
        <option value="lichess">Lichess</option>
        <option value="chesscom">Chess.com</option>
      </select>
    </div>
    <div class="form-group">
      <label for="username">Username</label>
      <input type="text" id="username" required placeholder="Enter username">
    </div>
    <div class="form-group">
      <label for="maxGames">Maximum Games</label>
      <input type="number" id="maxGames" value="1000" min="1" max="10000">
    </div>
    <button type="submit" class="btn">Start Import</button>
  </form>

  <div id="importProgress" style="display: none; margin-top: 24px;">
    <p><strong>Import in progress...</strong></p>
    <div class="progress-bar">
      <div class="progress-fill" id="importProgressFill" style="width: 0%"></div>
      <div class="progress-text" id="importProgressText">0%</div>
    </div>
  </div>
</div>

<div class="card">
  <h2>Sync Games</h2>
  <p style="color: var(--text-muted); font-size: 0.875rem; margin-bottom: 16px;">
    Fetch new games from all configured sources.
  </p>
  <button class="btn" onclick="startSync()">Sync Now</button>
  <div id="syncStatus" style="margin-top: 16px;"></div>
</div>

<div class="card">
  <h2>Analyze Games</h2>
  <div id="analysisMessage" style="display: none;"></div>

  <div id="analysisInfo" style="margin-bottom: 16px;">
    <p style="color: var(--text-muted); font-size: 0.875rem;">
      <span id="unanalyzedCount">-</span> games pending analysis
    </p>
  </div>

  <div id="analysisControls">
    <button class="btn" id="startAnalysisBtn" onclick="startAnalysis()">Analyze All Games</button>
    <button class="btn" id="stopAnalysisBtn" onclick="stopAnalysis()" style="display: none; background: var(--error);">Stop Analysis</button>
  </div>

  <div id="analysisProgress" style="display: none; margin-top: 24px;">
    <p><strong>Analysis in progress...</strong></p>
    <div class="progress-bar">
      <div class="progress-fill" id="analysisProgressFill" style="width: 0%"></div>
      <div class="progress-text" id="analysisProgressText">0%</div>
    </div>
  </div>
</div>

<div class="card">
  <h2>Backfill Game Phases</h2>
  <div id="backfillMessage" style="display: none;"></div>

  <div id="backfillInfo" style="margin-bottom: 16px;">
    <p style="color: var(--text-muted); font-size: 0.875rem;">
      Backfill phase data (opening/middlegame/endgame) for analyzed games.
      <br>
      <span id="backfillPendingCount">-</span> games pending phase backfill
    </p>
  </div>

  <div id="backfillControls">
    <button class="btn" id="startBackfillBtn" onclick="startBackfillPhases()">Backfill Phases</button>
  </div>

  <div id="backfillProgress" style="display: none; margin-top: 24px;">
    <p><strong>Backfill in progress...</strong></p>
    <div class="progress-bar">
      <div class="progress-fill" id="backfillProgressFill" style="width: 0%"></div>
      <div class="progress-text" id="backfillProgressText">0%</div>
    </div>
  </div>
</div>

<div class="card">
  <h2>Backfill ECO Codes</h2>
  <div id="ecoBackfillMessage" style="display: none;"></div>

  <div id="ecoBackfillInfo" style="margin-bottom: 16px;">
    <p style="color: var(--text-muted); font-size: 0.875rem;">
      Backfill ECO opening codes for analyzed games.
      <br>
      <span id="ecoBackfillPendingCount">-</span> games pending ECO classification
    </p>
  </div>

  <div id="ecoBackfillControls">
    <button class="btn" id="startEcoBackfillBtn" onclick="startBackfillECO()">Backfill ECO Codes</button>
  </div>

  <div id="ecoBackfillProgress" style="display: none; margin-top: 24px;">
    <p><strong>ECO backfill in progress...</strong></p>
    <div class="progress-bar">
      <div class="progress-fill" id="ecoBackfillProgressFill" style="width: 0%"></div>
      <div class="progress-text" id="ecoBackfillProgressText">0%</div>
    </div>
  </div>
</div>

<div class="card">
  <h2>Recent Jobs</h2>
  <table id="jobsTable">
    <thead>
      <tr>
        <th>Type</th>
        <th>Status</th>
        <th>Username</th>
        <th>Source</th>
        <th>Progress</th>
        <th>Created</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="jobsTableBody"
           hx-get="/api/jobs/html"
           hx-trigger="load, jobsRefresh from:body"
           hx-swap="innerHTML">
      <tr>
        <td colspan="7" style="text-align: center; color: var(--text-muted);">Loading...</td>
      </tr>
    </tbody>
  </table>
</div>

<div class="card" style="border-color: var(--error);">
  <h2 style="color: var(--error);">Danger Zone</h2>
  <div id="deleteAllMessage" style="display: none;"></div>
  <p style="color: var(--text-muted); font-size: 0.875rem; margin-bottom: 16px;">
    Delete all imported games, analysis results, puzzle attempts, and job history.
    <strong>This action cannot be undone.</strong> Your settings will be preserved.
  </p>
  <button class="btn" id="deleteAllBtn" onclick="confirmDeleteAll()" style="background: var(--error);">
    Delete All Data
  </button>

  <div id="deleteAllProgress" style="display: none; margin-top: 24px;">
    <p><strong>Deleting data...</strong></p>
    <div class="progress-bar">
      <div class="progress-fill" id="deleteAllProgressFill" style="width: 0%; background: var(--error);"></div>
      <div class="progress-text" id="deleteAllProgressText">0%</div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
  let currentJobId = null;
  let configuredUsernames = {};

  // LocalStorage keys
  const STORAGE_KEYS = {
    source: 'blunder_import_source',
    username: 'blunder_import_username',
    maxGames: 'blunder_import_maxGames'
  };

  // Trigger HTMX refresh of jobs table
  function refreshJobsTable() {
    htmx.trigger(document.body, 'jobsRefresh');
  }

  // Load configured usernames from settings
  async function loadConfiguredUsernames() {
    try {
      const resp = await fetch('/api/settings/usernames');
      if (resp.ok) {
        configuredUsernames = await resp.json();
      }
    } catch (err) {
      console.error('Failed to load configured usernames:', err);
    }
  }

  // Prefill username based on selected source
  function prefillUsername(source) {
    const usernameInput = document.getElementById('username');
    const currentValue = usernameInput.value.trim();

    // Only prefill if field is empty
    if (!currentValue && source) {
      if (source === 'lichess' && configuredUsernames.lichess_username) {
        usernameInput.value = configuredUsernames.lichess_username;
      } else if (source === 'chesscom' && configuredUsernames.chesscom_username) {
        usernameInput.value = configuredUsernames.chesscom_username;
      }
    }
  }

  // Save form values to localStorage
  function saveFormValues() {
    localStorage.setItem(STORAGE_KEYS.source, document.getElementById('source').value);
    localStorage.setItem(STORAGE_KEYS.username, document.getElementById('username').value);
    localStorage.setItem(STORAGE_KEYS.maxGames, document.getElementById('maxGames').value);
  }

  // Restore form values from localStorage
  function restoreFormValues() {
    const savedSource = localStorage.getItem(STORAGE_KEYS.source);
    const savedUsername = localStorage.getItem(STORAGE_KEYS.username);
    const savedMaxGames = localStorage.getItem(STORAGE_KEYS.maxGames);

    if (savedSource) {
      document.getElementById('source').value = savedSource;
    }
    if (savedUsername) {
      document.getElementById('username').value = savedUsername;
    }
    if (savedMaxGames) {
      document.getElementById('maxGames').value = savedMaxGames;
    }
  }

  // Initialize: Load configured usernames and restore form values
  async function initialize() {
    await loadConfiguredUsernames();
    restoreFormValues();

    // Prefill username based on restored source
    const restoredSource = document.getElementById('source').value;
    if (restoredSource && !document.getElementById('username').value) {
      prefillUsername(restoredSource);
    }
  }

  // Add event listener for source change
  document.getElementById('source').addEventListener('change', (e) => {
    prefillUsername(e.target.value);
    saveFormValues();
  });

  // Add event listeners to save form values on change
  document.getElementById('username').addEventListener('input', saveFormValues);
  document.getElementById('maxGames').addEventListener('input', saveFormValues);

  document.getElementById('importForm').addEventListener('submit', async (e) => {
    e.preventDefault();

    const source = document.getElementById('source').value;
    const username = document.getElementById('username').value;
    const maxGames = parseInt(document.getElementById('maxGames').value);

    try {
      const resp = await fetch('/api/import/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ source, username, max_games: maxGames })
      });

      const data = await resp.json();

      if (data.error) {
        showMessage('importMessage', 'error', 'Error: ' + data.error);
        return;
      }

      currentJobId = data.job_id;
      document.getElementById('importProgress').style.display = 'block';
      showMessage('importMessage', 'success', 'Import job started!');

    } catch (err) {
      showMessage('importMessage', 'error', 'Failed to start import: ' + err.message);
    }
  });

  async function startSync() {
    try {
      const resp = await fetch('/api/sync/start', { method: 'POST' });
      const data = await resp.json();

      document.getElementById('syncStatus').innerHTML =
        '<div class="message success">Sync started! Check Recent Jobs for progress.</div>';

      // HTMX will auto-refresh via WebSocket event

    } catch (err) {
      document.getElementById('syncStatus').innerHTML =
        '<div class="message error">Failed to start sync: ' + err.message + '</div>';
    }
  }

  function showMessage(elementId, type, text) {
    const el = document.getElementById(elementId);
    el.className = 'message ' + type;
    el.textContent = text;
    el.style.display = 'block';

    setTimeout(() => {
      el.style.display = 'none';
    }, 5000);
  }

  // Initialize on page load
  initialize();

  // Analysis management
  let analysisJobId = null;
  let analysisCheckInterval = null;

  async function loadAnalysisStatus() {
    try {
      // Load stats to get unanalyzed count
      const statsResp = await fetch('/api/stats');
      const stats = await statsResp.json();
      document.getElementById('unanalyzedCount').textContent = stats.pending_analysis || 0;

      // Load current analysis job status
      const statusResp = await fetch('/api/analysis/status');
      const status = await statusResp.json();

      if (status.status === 'running') {
        analysisJobId = status.job_id;
        showAnalysisProgress(status);
      } else if (status.status === 'no_jobs' || status.status === 'completed' || status.status === 'failed') {
        hideAnalysisProgress();
      }
    } catch (err) {
      console.error('Failed to load analysis status:', err);
    }
  }

  function showAnalysisProgress(job) {
    document.getElementById('analysisProgress').style.display = 'block';
    document.getElementById('startAnalysisBtn').style.display = 'none';
    document.getElementById('stopAnalysisBtn').style.display = 'inline-block';

    if (job.progress_total > 0) {
      const percent = Math.round((job.progress_current / job.progress_total) * 100);
      document.getElementById('analysisProgressFill').style.width = percent + '%';
      document.getElementById('analysisProgressText').textContent =
        `${job.progress_current}/${job.progress_total} (${percent}%)`;
    }
  }

  function hideAnalysisProgress() {
    document.getElementById('analysisProgress').style.display = 'none';
    document.getElementById('startAnalysisBtn').style.display = 'inline-block';
    document.getElementById('stopAnalysisBtn').style.display = 'none';

    if (analysisCheckInterval) {
      clearInterval(analysisCheckInterval);
      analysisCheckInterval = null;
    }

    analysisJobId = null;
  }

  async function startAnalysis() {
    try {
      const resp = await fetch('/api/analysis/start', { method: 'POST' });
      const data = await resp.json();

      if (data.error) {
        showMessage('analysisMessage', 'error', 'Error: ' + data.error);
        return;
      }

      analysisJobId = data.job_id;
      showMessage('analysisMessage', 'success', 'Analysis started!');

      // Show progress UI
      document.getElementById('analysisProgress').style.display = 'block';
      document.getElementById('startAnalysisBtn').style.display = 'none';
      document.getElementById('stopAnalysisBtn').style.display = 'inline-block';

      // WebSocket will handle progress updates

    } catch (err) {
      showMessage('analysisMessage', 'error', 'Failed to start analysis: ' + err.message);
    }
  }

  async function stopAnalysis() {
    if (!analysisJobId) return;

    try {
      const resp = await fetch(`/api/analysis/stop/${analysisJobId}`, { method: 'POST' });
      const data = await resp.json();

      showMessage('analysisMessage', 'success', 'Analysis stopped!');
      hideAnalysisProgress();
      loadJobs();
      loadAnalysisStatus();

    } catch (err) {
      showMessage('analysisMessage', 'error', 'Failed to stop analysis: ' + err.message);
    }
  }

  async function checkAnalysisStatus(jobId) {
    try {
      const resp = await fetch(`/api/import/status/${jobId}`);
      const job = await resp.json();

      if (job.error) {
        clearInterval(analysisCheckInterval);
        analysisCheckInterval = null;
        return;
      }

      // Update progress
      if (job.progress_total > 0) {
        const percent = Math.round((job.progress_current / job.progress_total) * 100);
        document.getElementById('analysisProgressFill').style.width = percent + '%';
        document.getElementById('analysisProgressText').textContent =
          `${job.progress_current}/${job.progress_total} (${percent}%)`;
      }

      // Show progress UI if running
      if (job.status === 'running') {
        document.getElementById('analysisProgress').style.display = 'block';
        document.getElementById('startAnalysisBtn').style.display = 'none';
        document.getElementById('stopAnalysisBtn').style.display = 'inline-block';
      }

      // Check if completed
      if (job.status === 'completed' || job.status === 'failed') {
        clearInterval(analysisCheckInterval);
        analysisCheckInterval = null;

        hideAnalysisProgress();

        if (job.status === 'completed') {
          const result = job.result || {};
          showMessage('analysisMessage', 'success',
            `Analysis completed! Analyzed: ${result.analyzed || 0}, Skipped: ${result.skipped || 0}`);
        } else {
          showMessage('analysisMessage', 'error', 'Analysis failed: ' + (job.error_message || 'Unknown error'));
        }

        loadJobs();
        loadAnalysisStatus();
      }

    } catch (err) {
      console.error('Failed to check analysis status:', err);
    }
  }

  // Load analysis status on page load
  loadAnalysisStatus();

  // Backfill phases management
  let backfillJobId = null;

  async function loadBackfillStatus() {
    try {
      // Load pending count
      const pendingResp = await fetch('/api/backfill-phases/pending');
      const pending = await pendingResp.json();
      document.getElementById('backfillPendingCount').textContent = pending.pending_count || 0;

      // Load current backfill job status
      const statusResp = await fetch('/api/backfill-phases/status');
      const status = await statusResp.json();

      if (status.status === 'running') {
        backfillJobId = status.job_id;
        showBackfillProgress(status);
      } else if (status.status === 'no_jobs' || status.status === 'completed' || status.status === 'failed') {
        hideBackfillProgress();
      }
    } catch (err) {
      console.error('Failed to load backfill status:', err);
    }
  }

  function showBackfillProgress(job) {
    document.getElementById('backfillProgress').style.display = 'block';
    document.getElementById('startBackfillBtn').style.display = 'none';

    if (job.progress_total > 0) {
      const percent = Math.round((job.progress_current / job.progress_total) * 100);
      document.getElementById('backfillProgressFill').style.width = percent + '%';
      document.getElementById('backfillProgressText').textContent =
        `${job.progress_current}/${job.progress_total} (${percent}%)`;
    }
  }

  function hideBackfillProgress() {
    document.getElementById('backfillProgress').style.display = 'none';
    document.getElementById('startBackfillBtn').style.display = 'inline-block';
    backfillJobId = null;
  }

  async function startBackfillPhases() {
    try {
      const resp = await fetch('/api/backfill-phases/start', { method: 'POST' });
      const data = await resp.json();

      if (data.detail) {
        showMessage('backfillMessage', 'error', 'Error: ' + data.detail);
        return;
      }

      backfillJobId = data.job_id;
      showMessage('backfillMessage', 'success', 'Backfill started!');

      // Show progress UI
      document.getElementById('backfillProgress').style.display = 'block';
      document.getElementById('startBackfillBtn').style.display = 'none';

    } catch (err) {
      showMessage('backfillMessage', 'error', 'Failed to start backfill: ' + err.message);
    }
  }

  // Load backfill status on page load
  loadBackfillStatus();

  // ECO backfill management
  let ecoBackfillJobId = null;

  async function loadECOBackfillStatus() {
    try {
      // Load pending count
      const pendingResp = await fetch('/api/backfill-eco/pending');
      const pending = await pendingResp.json();
      document.getElementById('ecoBackfillPendingCount').textContent = pending.pending_count || 0;

      // Load current backfill job status
      const statusResp = await fetch('/api/backfill-eco/status');
      const status = await statusResp.json();

      if (status.status === 'running') {
        ecoBackfillJobId = status.job_id;
        showECOBackfillProgress(status);
      } else if (status.status === 'no_jobs' || status.status === 'completed' || status.status === 'failed') {
        hideECOBackfillProgress();
      }
    } catch (err) {
      console.error('Failed to load ECO backfill status:', err);
    }
  }

  function showECOBackfillProgress(job) {
    document.getElementById('ecoBackfillProgress').style.display = 'block';
    document.getElementById('startEcoBackfillBtn').style.display = 'none';

    if (job.progress_total > 0) {
      const percent = Math.round((job.progress_current / job.progress_total) * 100);
      document.getElementById('ecoBackfillProgressFill').style.width = percent + '%';
      document.getElementById('ecoBackfillProgressText').textContent =
        `${job.progress_current}/${job.progress_total} (${percent}%)`;
    }
  }

  function hideECOBackfillProgress() {
    document.getElementById('ecoBackfillProgress').style.display = 'none';
    document.getElementById('startEcoBackfillBtn').style.display = 'inline-block';
    ecoBackfillJobId = null;
  }

  async function startBackfillECO() {
    try {
      const resp = await fetch('/api/backfill-eco/start', { method: 'POST' });
      const data = await resp.json();

      if (data.detail) {
        showMessage('ecoBackfillMessage', 'error', 'Error: ' + data.detail);
        return;
      }

      ecoBackfillJobId = data.job_id;
      showMessage('ecoBackfillMessage', 'success', 'ECO backfill started!');

      // Show progress UI
      document.getElementById('ecoBackfillProgress').style.display = 'block';
      document.getElementById('startEcoBackfillBtn').style.display = 'none';

    } catch (err) {
      showMessage('ecoBackfillMessage', 'error', 'Failed to start ECO backfill: ' + err.message);
    }
  }

  // Load ECO backfill status on page load
  loadECOBackfillStatus();

  // Delete all data
  let deleteAllJobId = null;

  async function loadDeleteAllStatus() {
    try {
      const statusResp = await fetch('/api/data/delete-status');
      const status = await statusResp.json();

      if (status.status === 'running') {
        deleteAllJobId = status.job_id;
        showDeleteAllProgress(status);
      } else if (status.status === 'no_jobs' || status.status === 'completed' || status.status === 'failed') {
        hideDeleteAllProgress();
      }
    } catch (err) {
      console.error('Failed to load delete all status:', err);
    }
  }

  function showDeleteAllProgress(job) {
    document.getElementById('deleteAllProgress').style.display = 'block';
    document.getElementById('deleteAllBtn').style.display = 'none';

    if (job.progress_total > 0) {
      const percent = Math.round((job.progress_current / job.progress_total) * 100);
      document.getElementById('deleteAllProgressFill').style.width = percent + '%';
      document.getElementById('deleteAllProgressText').textContent =
        `${job.progress_current}/${job.progress_total} tables (${percent}%)`;
    }
  }

  function hideDeleteAllProgress() {
    document.getElementById('deleteAllProgress').style.display = 'none';
    document.getElementById('deleteAllBtn').style.display = 'inline-block';
    deleteAllJobId = null;
  }

  async function confirmDeleteAll() {
    const confirmed = confirm(
      'Are you sure you want to delete ALL data?\n\n' +
      'This will permanently remove:\n' +
      '• All imported games\n' +
      '• All analysis results\n' +
      '• All puzzle attempts\n' +
      '• All job history\n\n' +
      'This action cannot be undone!'
    );

    if (!confirmed) return;

    // Double confirmation for safety
    const doubleConfirmed = confirm(
      'This is your final warning!\n\n' +
      'Click OK to permanently delete all data.'
    );

    if (!doubleConfirmed) return;

    try {
      const resp = await fetch('/api/data/all', { method: 'DELETE' });
      const data = await resp.json();

      if (data.job_id) {
        deleteAllJobId = data.job_id;
        showMessage('deleteAllMessage', 'success', 'Delete job started!');

        // Show progress UI
        document.getElementById('deleteAllProgress').style.display = 'block';
        document.getElementById('deleteAllBtn').style.display = 'none';
      } else {
        showMessage('deleteAllMessage', 'error', 'Failed to start delete job');
      }
    } catch (err) {
      showMessage('deleteAllMessage', 'error', 'Failed to delete data: ' + err.message);
    }
  }

  // Load delete all status on page load
  loadDeleteAllStatus();

  // Initialize WebSocket for real-time updates
  wsClient.connect();

  // Subscribe to all job-related events
  wsClient.subscribe([
    'job.created',
    'job.status_changed',
    'job.progress_updated',
    'job.completed',
    'job.failed'
  ]);

  // Debounced HTMX refresh (at most once per second)
  let jobsRefreshTimeout = null;
  function debouncedRefreshJobsTable() {
    if (jobsRefreshTimeout) return;
    jobsRefreshTimeout = setTimeout(() => {
      refreshJobsTable();
      jobsRefreshTimeout = null;
    }, 1000);
  }

  // Handle job progress updates
  wsClient.on('job.progress_updated', (data) => {
    // Update import progress bar directly (no table refresh needed)
    if (data.job_id === currentJobId) {
      const percent = data.percent;
      document.getElementById('importProgressFill').style.width = percent + '%';
      document.getElementById('importProgressText').textContent =
        `${data.current}/${data.total} (${percent}%)`;
    }

    // Update analysis progress bar directly
    if (data.job_id === analysisJobId) {
      const percent = data.percent;
      document.getElementById('analysisProgressFill').style.width = percent + '%';
      document.getElementById('analysisProgressText').textContent =
        `${data.current}/${data.total} (${percent}%)`;
    }

    // Update backfill progress bar directly
    if (data.job_id === backfillJobId) {
      const percent = data.percent;
      document.getElementById('backfillProgressFill').style.width = percent + '%';
      document.getElementById('backfillProgressText').textContent =
        `${data.current}/${data.total} (${percent}%)`;
    }

    // Update ECO backfill progress bar directly
    if (data.job_id === ecoBackfillJobId) {
      const percent = data.percent;
      document.getElementById('ecoBackfillProgressFill').style.width = percent + '%';
      document.getElementById('ecoBackfillProgressText').textContent =
        `${data.current}/${data.total} (${percent}%)`;
    }

    // Update delete all progress bar directly
    if (data.job_id === deleteAllJobId) {
      const percent = data.percent;
      document.getElementById('deleteAllProgressFill').style.width = percent + '%';
      document.getElementById('deleteAllProgressText').textContent =
        `${data.current}/${data.total} tables (${percent}%)`;
    }

    // Debounced table refresh for progress column
    debouncedRefreshJobsTable();
  });

  // Handle job status changes
  wsClient.on('job.status_changed', (data) => {
    // Handle import job completion
    if (data.job_id === currentJobId) {
      if (data.status === 'completed') {
        document.getElementById('importProgress').style.display = 'none';
        showMessage('importMessage', 'success', 'Import completed!');
        currentJobId = null;
      } else if (data.status === 'failed') {
        document.getElementById('importProgress').style.display = 'none';
        showMessage('importMessage', 'error', 'Import failed: ' + (data.error_message || 'Unknown error'));
        currentJobId = null;
      }
    }

    // Handle analysis job completion
    if (data.job_id === analysisJobId) {
      if (data.status === 'completed') {
        hideAnalysisProgress();
        showMessage('analysisMessage', 'success', 'Analysis completed!');
        loadAnalysisStatus();
      } else if (data.status === 'failed') {
        hideAnalysisProgress();
        showMessage('analysisMessage', 'error', 'Analysis failed: ' + (data.error_message || 'Unknown error'));
        loadAnalysisStatus();
      }
    }

    // Handle backfill job completion
    if (data.job_id === backfillJobId) {
      if (data.status === 'completed') {
        hideBackfillProgress();
        showMessage('backfillMessage', 'success', 'Backfill completed!');
        loadBackfillStatus();
      } else if (data.status === 'failed') {
        hideBackfillProgress();
        showMessage('backfillMessage', 'error', 'Backfill failed: ' + (data.error_message || 'Unknown error'));
        loadBackfillStatus();
      }
    }

    // Handle ECO backfill job completion
    if (data.job_id === ecoBackfillJobId) {
      if (data.status === 'completed') {
        hideECOBackfillProgress();
        showMessage('ecoBackfillMessage', 'success', 'ECO backfill completed!');
        loadECOBackfillStatus();
      } else if (data.status === 'failed') {
        hideECOBackfillProgress();
        showMessage('ecoBackfillMessage', 'error', 'ECO backfill failed: ' + (data.error_message || 'Unknown error'));
        loadECOBackfillStatus();
      }
    }

    // Handle delete all job completion
    if (data.job_id === deleteAllJobId) {
      if (data.status === 'completed') {
        hideDeleteAllProgress();
        showMessage('deleteAllMessage', 'success', 'All data deleted! Refreshing page...');
        // Refresh page to show updated state
        setTimeout(() => window.location.reload(), 2000);
      } else if (data.status === 'failed') {
        hideDeleteAllProgress();
        showMessage('deleteAllMessage', 'error', 'Delete failed: ' + (data.error_message || 'Unknown error'));
      }
    }

    // Always refresh jobs table on status change (HTMX handles it efficiently)
    refreshJobsTable();
  });

  // Handle job creation (trigger HTMX refresh)
  wsClient.on('job.created', () => {
    refreshJobsTable();
  });
</script>
{% endblock %}
